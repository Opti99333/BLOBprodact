 import * as Framer from "framer"; import * as React from "react"; import { createPortal } from "react-dom"; import * as ReactDOM from "react-dom/client"; const routes = {augiA20Il: {elements: {B2nUNr_PH: "roadmap", BNTS7T06J: "tokenomics", fG5lBSSQ4:
"how-to-buy", fY1i5DyBD: "hero", gNsm22jQM: "faq", M8l5gH3jw: "tokenomics-1", nvL53Xnap: "features", pyD_KHTvn: "footer", rPEgAqoBb: "about"}, page: Framer.lazy(() => import("https://framerusercontent.com/modules/qVbcwibHaGVbI20XVpHs/84gaETE2IKNNVI5JUN0T/augiA20Il.js")),
path: "/"}, yAwDOL9_Q: {elements: {}, page: Framer.lazy(() => import("https://framerusercontent.com/modules/g9UG5S2zvog8zaFak2e8/Mmu6LaEo2MXrdlGkdybV/yAwDOL9_Q.js")), path: "/404"}} const locales = [{code: "en", id: "default", name: "English", slug: ""}]
const collectionUtils = {} const framerSiteId = "7a346507f1c4aa67ddd559fcf89ba2a44a89dc82652afd3b3d880754346ced32" export async function getPageRoot({ routeId, pathVariables, localeId }) { // We don't want the initial render to immediately have to suspend.
await routes[routeId].page.preload() const content = React.createElement( Framer.PageRoot, { isWebsite: true, routeId, pathVariables, routes, collectionUtils, framerSiteId, notFoundPage: Framer.lazy(() => import("https://framerusercontent.com/modules/g9UG5S2zvog8zaFak2e8/Mmu6LaEo2MXrdlGkdybV/yAwDOL9_Q.js")),
isReducedMotion: undefined, localeId, locales, preserveQueryParams: undefined, siteCanonicalURL: "https://www.BLOB CTOlabs.xyz", EditorBar: (() => { const isBot = typeof window !== "undefined" && /bot|-google|google-|yandex|ia_archiver|crawl|spider/iu.test(navigator.userAgent)
const isServerSideRendered = typeof window === "undefined" const preventLoadingEditorBar = isBot || isServerSideRendered if (preventLoadingEditorBar) return return Framer.lazy(async () => { const { createEditorBar } = await import("https://edit.framer.com/init.mjs")
return { default: createEditorBar({ dependencies: { __version: 1, framer: { useCurrentRoute: Framer.useCurrentRoute, useLocaleInfo: Framer.useLocaleInfo, useRouter: Framer.useRouter, }, react: { createElement: React.createElement, memo: React.memo, useCallback:
React.useCallback, useEffect: React.useEffect, useRef: React.useRef, useState: React.useState, }, "react-dom": { createPortal }, }, }), } }) })() , } ) const contentWithFeaturesContext = React.createElement( Framer.LibraryFeaturesProvider, { children:
content, value: {codeBoundaries: true, editorBarOnPageEditing: false, editorBarSubtle: true, pauseOffscreen: true, replaceNestedLinks: true} } ) const contentWithGracefullyDegradingErrorBoundary = React.createElement(Framer.GracefullyDegradingErrorBoundary,
{ children: contentWithFeaturesContext }) const page = React.createElement(Framer.PageEffectsProvider, { children: contentWithGracefullyDegradingErrorBoundary, value: {routes: {}} }) return page } const isBrowser = typeof document !== "undefined" if (isBrowser)
{ window.__framer_importFromPackage = (packageAndFilename, exportIdentifier) => () => { return React.createElement(Framer.ErrorPlaceholder, { error: 'Package component not supported: "' + exportIdentifier + '" in "' + packageAndFilename + '"' }) } //
A lot of libraries assume process.env.NODE_ENV is present in runtime/buildtime, so we are polyfilling it window.process = { ...window.process, env: { ...(window.process ? window.process.env: undefined), NODE_ENV: "production" } } window.__framer_events
= window.__framer_events || [] // Fallback support for stack gaps Framer.installFlexboxGapWorkaroundIfNeeded() const container = document.getElementById("main") // We know that #main is parsed before this script, so we don't need to wait for DOMContentLoaded
or similar events. if ("framerHydrateV2" in container.dataset) main(true, container) else main(false, container) } function track() { if (!isBrowser) return window.__framer_events.push(arguments) } async function main(shouldHydrate, container) { function
handleError(error, errorInfo, recoverable = true) { if (error.caught || window.__framer_hadFatalError) return // we already logged it const componentStack = errorInfo?.componentStack if (recoverable) { console.warn("Recoverable error has happened. Please
check any custom code or code overrides to fix server/client mismatches:\n", error, componentStack) // we only want to collect 1%, because this can be quite noisy (floods the data pipeline) if (Math.random() > 0.01) return } else { console.error("Fatal
crash has happened. If you are the author of this website, please report this issue to the Framer team via https://www.framer.community/:\n", error, componentStack) } track(recoverable ? "published_site_load_recoverable_error" : "published_site_load_error",
{ message: String(error), componentStack, // componentStack is more useful stack: componentStack ? undefined : error instanceof Error && typeof error.stack === "string" ? error.stack : null, }) } try { let routeId, localeId, pathVariables, breakpoints
if (shouldHydrate) { const routeData = JSON.parse(container.dataset.framerHydrateV2) routeId = routeData.routeId localeId = routeData.localeId pathVariables = routeData.pathVariables breakpoints = routeData.breakpoints routeId = Framer.patchRoutesForABTesting(routes,
routeId) // Prioritize optimized route id to avoid flickering in browsers not supporting the server-timing header (Safari older than 16.4) } else { Framer.patchRoutesForABTesting(routes, undefined) // This must happen before inferInitialRouteFromPath
const routeData = Framer.inferInitialRouteFromPath(routes, decodeURIComponent(location.pathname), true, locales) routeId = routeData.routeId localeId = routeData.localeId pathVariables = routeData.pathVariables } if (typeof window !== "undefined") { void
(async () => { const route = routes[routeId] const defaultLocaleId = "default" const framerLocale = locales.find(({ id }) => !localeId ? id === defaultLocaleId : id === localeId).code let collectionItemId = null if (route?.collectionId && collectionUtils)
{ const utils = await collectionUtils[route.collectionId]?.() const [slug] = Object.values(pathVariables) if (utils && typeof slug === "string") { collectionItemId = (await utils.getRecordIdBySlug(slug, framerLocale || undefined)) ?? null } } const resolvedDateTimeOptions
= Intl.DateTimeFormat().resolvedOptions() const timezone = resolvedDateTimeOptions.timeZone const locale = resolvedDateTimeOptions.locale // wait for the page to be activated before sending the pageview event // https://developer.chrome.com/docs/web-platform/prerender-pages#impact-on-analytics
await new Promise((resolve) => { if (document.prerendering) { document.addEventListener("prerenderingchange", resolve, { once: true }) } else { resolve() } }) window.__framer_events.push([ "published_site_pageview", { framerSiteId: framerSiteId ?? null,
routePath: route?.path || "/", collectionItemId, framerLocale: framerLocale || null, webPageId: route?.abTestingVariantId ?? routeId, abTestId: route?.abTestId, referrer: document.referrer || null, url: window.location.href, hostname: window.location.hostname
|| null, pathname: window.location.pathname || null, hash: window.location.hash || null, search: window.location.search || null, timezone, locale, } ]) })() } const page = await getPageRoot({ routeId, localeId, pathVariables }) if (shouldHydrate) { Framer.withPerformanceMarks("framer-rewrite-breakpoints",
() => { Framer.removeHiddenBreakpointLayersV2(breakpoints) window.__framer_onRewriteBreakpoints?.(breakpoints) }) const startTransition = React.startTransition startTransition(() => { Framer.markHydrationStart() Framer.setInitialHydrationState() if (true)
Framer.turnOffReactEventHandling() ReactDOM.hydrateRoot(container, page, { onRecoverableError: handleError }) }) } else { ReactDOM.createRoot(container, { onRecoverableError: handleError }).render(page) } } catch (error) { handleError(error, undefined,
false) throw error } }